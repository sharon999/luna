# -*- coding: utf-8 -*-
"""app_main.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1eyoiGlyqYEPJWWYbCrmWYxKxpR4SY60g
"""

import io, zipfile
import numpy as np
from PIL import Image, ImageDraw
import streamlit as st
import os, tempfile, importlib.util, types
import requests
import torch
import tempfile
import gdown

import tempfile

import modelyolo4
import torch

import modelyolo4full

import training_core
import pandas as pd
import os

# ×œ×¦×™×•×¨ ×’×¨×¤×™× ××•×‘× ×™× ×©×œ Streamlit
import matplotlib.pyplot as plt
from training_core import run_training_only_train


# ===================== ×‘×¡×™×¡ ×•×¢×™×¦×•×‘ =====================
st.set_page_config(page_title="Lung Nodule System", layout="wide")
device = torch.device("cuda" if torch.cuda.is_available() else "cpu")
FULL_MODEL_URL = "https://drive.usercontent.google.com/uc?id=1zvhTiigngEF5QHH5M8-QSZn18C6SiSNp&export=download"


FULL_MODEL_URL = "https://drive.usercontent.google.com/uc?id=1zvhTiigngEF5QHH5M8-QSZn18C6SiSNp&export=download"

@st.cache_resource(show_spinner=True)
def load_full_model_from_url(url: str):
    import io, requests
    with st.spinner("××•×¨×™×“/×˜×•×¢×Ÿ ××•×“×œ ××œ×..."):
        r = requests.get(url, timeout=300)
        r.raise_for_status()
        buf = io.BytesIO(r.content)
        # PyTorch 2.6 ×“×•×¨×©×ª ×œ×¦×™×™×Ÿ ×‘××¤×•×¨×© weights_only=False ×œ×˜×¢×™× ×” ×©×œ ××•×“×œ ××œ×
        m = torch.load(buf, map_location=device, weights_only=False)
        m.to(device).eval()
        return m


# ××–×”×” ×”×§×•×‘×¥ ×‘×“×¨×™×™×‘ (××¤×©×¨ ×’× ×œ×ª×ª URL; ×”×¤×•× ×§×¦×™×” ×ª×˜×¤×œ)
FULL_MODEL_ID = "1Qx4POlUFdoLmtv0lPuq-Cd8KP86X5LKo"
@st.cache_resource(show_spinner="××•×¨×™×“/×˜×•×¢×Ÿ ××•×“×œ ××œ×...")
def load_full_model_from_drive(url_or_id):
    import io, torch

    # 1) ×”×•×¨×“×” ×—×¡×™× ×” ××“×¨×™×™×‘ (×›×•×œ×œ confirm-token). ××©×ª××© ×‘×¤×•× ×§×¦×™×” ×©×›×‘×¨ ××¦×œ×š.
    raw = _gdrive_download_bytes(url_or_id)

    # 2) ×”×’× ×” ××¤× ×™ HTML ×©××ª×—×–×” ×œ×§×•×‘×¥ ×‘×™× ××¨×™ â€“ ×’×•×¨× ×œ-"invalid load key, '<'"
    head = raw[:256].lower()
    if b"<html" in head or b"<!doctype html" in head or head[:1] == b"<":
        preview = raw[:200].decode("utf-8", errors="ignore")
        raise RuntimeError("Google Drive ×”×—×–×™×¨ HTML ×‘××§×•× ×§×•×‘×¥ ×‘×™× ××¨×™. ×‘×“×§×™ ×©×™×ª×•×£ ×•×§×™×©×•×¨. ×ª×¦×•×’×” ×¨××©×•× ×™×ª:\n" + preview)

    # 3) × ×™×¡×™×•×Ÿ ×˜×¢×™× ×”: ×§×•×“× ×‘×¨×™×¨×ª-××—×“×œ (×‘-PyTorch 2.6 ×–×” weights_only=True),
    #    ×•×× × ×›×©×œ (Unsupported operand / Pickle) × × ×¡×” weights_only=False.
    buf = io.BytesIO(raw)
    try:
        obj = torch.load(buf, map_location=device)
    except Exception as e1:
        buf.seek(0)
        try:
            obj = torch.load(buf, map_location=device, weights_only=False)
        except Exception as e2:
            raise RuntimeError("×˜×¢×™× ×ª ××•×“×œ × ×›×©×œ×” ×’× ×œ××—×¨ weights_only=False.\n×©×’×™××” 1: {}\n×©×’×™××” 2: {}".format(e1, e2))

    # 4) ×× ×–×” state_dict â€“ × ×‘× ×” ××•×“×œ ×•× ×¢××™×¡ ×œ×ª×•×›×•. ×× ×–×” ××•×“×•×œ â€“ ×¤×©×•×˜ ×œ×”×—×–×™×¨.
    if isinstance(obj, dict):
        # ×–×” state_dict: ×—×™×™×‘×™× build_model ××”×§×•×“ ×©×œ×š
        model = build_model().to(device)
        model.load_state_dict(obj, strict=False)  # strict=False ×›×“×™ ×œ× ×œ×”×™×ª×§×¢ ×¢×œ ××¤×ª×—×•×ª ×©×•×œ×™×™×
        model.eval()
        return model

    if not isinstance(obj, torch.nn.Module):
        raise RuntimeError("×”××•×‘×™×™×§×˜ ×©× ×˜×¢×Ÿ ××™× ×• torch.nn.Module ×•××™× ×• state_dict. ×•×“××™ ×©×”×§×•×‘×¥ × ×›×•×Ÿ.")

    obj.to(device).eval()
    return obj







THEME_CSS = """
<style>
html, body, [data-testid="stAppViewContainer"] { background-color: #E6F4FF; color: #000; }
[data-testid="stHeader"], [data-testid="stToolbar"] { background: transparent; }
[data-testid="stSidebar"] { background-color: #E6F4FF !important; }
h1 { font-size: 34px !important; font-weight: 800; color:#003366 !important; }
h2 { font-size: 28px !important; font-weight: 700; color:#003366 !important; }
h3 { font-size: 28px !important; font-weight: 700; color:#003366 !important; }
h4, h5, h6 { color: #003366 !important; }
p, span, label, div { font-size: 20px !important; color:#000 !important; }

/* ×›×¤×ª×•×¨×™× ×’×“×•×œ×™× */
.stButton > button, .stDownloadButton > button {
    font-size: 22px !important;
    line-height: 1.2 !important;
    font-weight: 600 !important;
    padding: 16px 16px !important;
    border-radius: 12px !important;
    background-color: #ffffff !important;
    color: #003366 !important;
    border: 2px solid #003366 !important;
    transition: all 0.15s ease-in-out !important;
}

/* ×›×¤×ª×•×¨×™ Back: ×›×œ ×›×¤×ª×•×¨ ××¡×•×’ secondary ×™×”×™×” â€œ×œ×™× ×§â€ */
[data-testid="baseButton-secondary"] {
    background: transparent !important;
    border: none !important;
    color: #003366 !important;
    text-decoration: underline !important;
    box-shadow: none !important;
    padding: 0 !important;
    font-size: 20px !important;
    font-weight: 600 !important;
    line-height: 1.2 !important;
}

/* ×—×©×•×‘: ×œ× ×œ×©×‘×•×¨ ××ª ×©××¨ ×”×›×¤×ª×•×¨×™× (primary) */
[data-testid="baseButton-primary"] {
    font-size: 22px !important;
    line-height: 1.2 !important;
    font-weight: 600 !important;
    padding: 16px 16px !important;
    border-radius: 12px !important;
    background-color: #ffffff !important;
    color: #003366 !important;
    border: 2px solid #003366 !important;
    transition: all 0.15s ease-in-out !important;
}


/* ×—×©×•×‘: ×”×™×œ×“×™× ×‘×ª×•×š ×”×›×¤×ª×•×¨ ×™×•×¨×©×™× ××ª ×”×’×•×“×œ ×©×œ ×”×›×¤×ª×•×¨ */
.stButton > button *, .stDownloadButton > button * {
    font-size: inherit !important;
}


.center { text-align:center; }
.subtle { color:#003366; }
.hr { border-top:1px solid rgba(0,0,0,0.15); margin: 0.5rem 0 1rem; }
</style>
"""
st.markdown(THEME_CSS, unsafe_allow_html=True)

if "page" not in st.session_state:
    st.session_state.page = "home"

# ===================== ×§×™×©×•×¨×™× ×œ×§×•×“ ×”××•×“×œ ×•×œ××©×§×œ×™× =====================
# ×“×•×’××”: https://drive.google.com/uc?id=<FILE_ID>
#MODEL_PY_URL = "https://drive.google.com/uc?export=download&id=19M7TwXrQXFJ-UqJ-4v3lul6JmSNgYa9w"

#WEIGHTS_URL = "https://drive.google.com/uc?export=download&id=1poyGTKmN_CS4qdSbKaAtJ_MaoOQfnr2R"

# ===== Direct-download (no HTML interstitial) =====
#MODEL_PY_URL = "https://drive.usercontent.google.com/uc?id=19M7TwXrQXFJ-UqJ-4v3lul6JmSNgYa9w&export=download"
#WEIGHTS_URL  = "https://drive.usercontent.google.com/uc?id=1poyGTKmN_CS4qdSbKaAtJ_MaoOQfnr2R&export=download"
MODEL_PY_URL = "19M7TwXrQXFJ-UqJ-4v3lul6JmSNgYa9w"
WEIGHTS_URL  = "1poyGTKmN_CS4qdSbKaAtJ_MaoOQfnr2R"


# ===================== Utilities ×œ××¡×š ×”-TEST =====================



def slice_to_pil(arr2d, vmin=None, vmax=None):
    import numpy as np
    from PIL import Image
    arr = arr2d.astype(np.float32)
    if vmin is None or vmax is None:
        lo, hi = np.percentile(arr, [2, 98])
    else:
        lo, hi = float(vmin), float(vmax)
    if hi <= lo:
        lo, hi = float(arr.min()), float(arr.max())
    arr = np.clip((arr - lo) / max(hi - lo, 1e-6), 0.0, 1.0)
    return Image.fromarray((arr * 255).astype(np.uint8), mode="L").convert("RGB")

def clamp(val, lo, hi):
    return int(max(lo, min(hi, val)))

def draw_square(drw: ImageDraw.ImageDraw, cx, cy, diam, color=(0,255,0)):
    r = diam/2.0
    drw.rectangle([(cx-r, cy-r), (cx+r, cy+r)], outline=color, width=2)

def infer_order(arr, Z, Y, X):
    if arr is None or arr.size == 0 or arr.ndim != 2 or arr.shape[1] != 5:
        return "zyx"
    def score(order):
        cnt = 0
        for row in arr:
            if order == "zyx":
                z, y, x = row[1], row[2], row[3]
            else:
                x, y, z = row[1], row[2], row[3]
            if (0 <= z < Z) and (0 <= y < Y) and (0 <= x < X):
                cnt += 1
        return cnt
    return "zyx" if score("zyx") >= score("xyz") else "xyz"

def parse_boxes(arr, Z, Y, X):
    boxes = []
    if arr is None or arr.size == 0: return boxes, "zyx"
    if arr.ndim != 2 or arr.shape[1] != 5:
        st.warning("âš ï¸ labels/preds ×—×™×™×‘×™× ×œ×”×™×•×ª ×‘×¦×•×¨×” (N,5). ××“×œ×’×ª.")
        return boxes, "zyx"
    order = infer_order(arr, Z, Y, X)
    for row in arr:
        cls = int(row[0])
        if order == "zyx":
            z, y, x, d = float(row[1]), float(row[2]), float(row[3]), float(row[4])
        else:
            x, y, z, d = float(row[1]), float(row[2]), float(row[3]), float(row[4])
        boxes.append((z, y, x, d, cls))
    return boxes, order

def to_box_coords(z, y, x, d):
    r = d/2.0
    return (z-r, z+r, y-r, y+r, x-r, x+r)

def iou3d(b1, b2):
    z0a,z1a,y0a,y1a,x0a,x1a = b1
    z0b,z1b,y0b,y1b,x0b,x1b = b2
    iz = max(0.0, min(z1a,z1b) - max(z0a,z0b))
    iy = max(0.0, min(y1a,y1b) - max(y0a,y0b))
    ix = max(0.0, min(x1a,x1b) - max(x0a,x0b))
    inter = iz*iy*ix
    vol_a = (z1a-z0a)*(y1a-y0a)*(x1a-x0a)
    vol_b = (z1b-z0b)*(y1b-y0b)*(x1b-x0b)
    union = vol_a + vol_b - inter
    return 0.0 if union <= 0 else inter/union

def match_greedy(gt_boxes, pd_boxes, iou_thr=0.1):
    gt_coords = [to_box_coords(*b[:4]) for b in gt_boxes]
    pd_coords = [to_box_coords(*b[:4]) for b in pd_boxes]
    used_gt, used_pd, matches, cand = set(), set(), [], []
    for gi, gc in enumerate(gt_coords):
        for pi, pc in enumerate(pd_coords):
            iou = iou3d(gc, pc)
            if iou >= iou_thr: cand.append((iou, gi, pi))
    cand.sort(reverse=True)
    for iou, gi, pi in cand:
        if gi in used_gt or pi in used_pd: continue
        used_gt.add(gi); used_pd.add(pi); matches.append((gi, pi, iou))
    unmatched_gt = [i for i in range(len(gt_boxes)) if i not in used_gt]
    unmatched_pd = [i for i in range(len(pd_boxes)) if i not in used_pd]
    return matches, unmatched_gt, unmatched_pd

# ===================== ×¢×–×¨: ×”×•×¨×“×”/×™×™×‘×•× ××•×“×œ ×•×˜×¢×™× ×ª ××©×§×œ×™× =====================





def _force_usercontent(url: str) -> str:
    import re
    # ××•×¦×™××™× FILE_ID ×’× ××œ×™× ×§ /d/<id>/ ×•×’× ×Ö¾id=<id>
    m = re.search(r'id=([A-Za-z0-9_-]+)', url)
    if not m:
        m = re.search(r'/d/([A-Za-z0-9_-]+)(/|$)', url)
    fid = m.group(1) if m else None
    if fid:
        return f"https://drive.usercontent.google.com/uc?id={fid}&export=download"
    return url

import re, requests

def _extract_file_id(url_or_id: str) -> str | None:
    """××§×‘×œ ×§×™×©×•×¨ ×“×¨×™×™×‘ ××• ID ×•××—×–×™×¨ File ID ×ª×§×™×Ÿ."""
    # ×›×‘×¨ ID × ×§×™?
    if re.fullmatch(r"[A-Za-z0-9_-]{20,}", url_or_id):
        return url_or_id
    # ×¤×•×¨××˜×™× × ×¤×•×¦×™×:
    m = re.search(r"id=([A-Za-z0-9_-]+)", url_or_id)
    if not m:
        m = re.search(r"/d/([A-Za-z0-9_-]+)(?:/|$)", url_or_id)
    return m.group(1) if m else None

def _download_binary1(url_or_id: str) -> bytes:
    """
    ××•×¨×™×“ ×§×•×‘×¥ ×‘×™× ××¨×™ (×›××• weights.pt) ×-Google Drive (ID ××• URL) ×‘×××¦×¢×•×ª gdown
    ×•××—×–×™×¨ bytes.
    """
    with tempfile.NamedTemporaryFile(delete=False, suffix=".bin") as tmp:
        tmp_path = tmp.name

    if "drive.google.com" not in url_or_id and "http" not in url_or_id:
        url = f"https://drive.google.com/uc?export=download&id={url_or_id}"
    else:
        url = url_or_id

    gdown.download(url, tmp_path, quiet=True)

    with open(tmp_path, "rb") as f:
        return f.read()

def _download_binary(url_or_id: str) -> bytes:
    """
    ××•×¨×™×“ ×§×•×‘×¥ ×‘×™× ××¨×™ (×›××• weights.pt) ×-Google Drive (ID ××• URL) ×‘×××¦×¢×•×ª gdown
    ×•××—×–×™×¨ bytes.
    """
    with tempfile.NamedTemporaryFile(delete=False, suffix=".bin") as tmp:
        tmp_path = tmp.name

    if "drive.google.com" not in url_or_id and "http" not in url_or_id:
        url = f"https://drive.google.com/uc?export=download&id={url_or_id}"
    else:
        url = url_or_id

    gdown.download(url, tmp_path, quiet=True)

    with open(tmp_path, "rb") as f:
        return f.read()


def _gdrive_download_bytes(url_or_id: str, timeout=300) -> bytes:
    """
    ××•×¨×™×“ ×§×•×‘×¥ ×-Google Drive ×‘××•×¤×Ÿ ×—×¡×™×Ÿ:
    1) × ×™×¡×™×•×Ÿ ×“×¨×š usercontent (×œ×¨×•×‘ ××¡×¤×™×§)
    2) ×× ××ª×§×‘×œ HTML, ×–×¨×™××ª confirm-token ×©×œ Drive
    """
    fid = _extract_file_id(url_or_id) or url_or_id
    sess = requests.Session()

    # × ×™×¡×™×•×Ÿ 1: usercontent (×™×©×™×¨)
    u1 = f"https://drive.usercontent.google.com/uc?id={fid}&export=download"
    r = sess.get(u1, timeout=timeout, allow_redirects=True)
    ct = (r.headers.get("Content-Type") or "").lower()
    if ("text/html" not in ct) and (not r.text.lstrip().startswith("<!DOCTYPE html")):
        r.raise_for_status()
        return r.content

    # × ×™×¡×™×•×Ÿ 2: confirm-token flow
    u2 = "https://drive.google.com/uc?export=download"
    r = sess.get(u2, params={"id": fid}, timeout=timeout, allow_redirects=True)
    token = None
    # ×˜×•×§×Ÿ × ××¦× ×œ×¢×™×ª×™× ×‘×¢×•×’×™×•×ª ×‘×©× download_warning/confirm
    for k, v in r.cookies.items():
        if k.startswith("download_warning") or k == "confirm":
            token = v
            break
    if not token:
        # ×œ×¤×¢××™× ××’×™×¢ ×‘×ª×•×š HTML
        m = re.search(r"confirm=([0-9A-Za-z_]+)", r.text)
        token = m.group(1) if m else None

    params = {"id": fid}
    if token:
        params["confirm"] = token
    r2 = sess.get(u2, params=params, timeout=timeout, allow_redirects=True)
    ct2 = (r2.headers.get("Content-Type") or "").lower()
    if "text/html" in ct2 and r2.text.lstrip().startswith("<!DOCTYPE html"):
        raise RuntimeError("Drive still returned HTML page (no raw file). Check sharing & link.")
    r2.raise_for_status()
    return r2.content











def infer_nodules(volume_np, model, device):
    import numpy as np, torch
    vol = volume_np.astype(np.float32)
    vmin, vmax = float(vol.min()), float(vol.max())
    if vmax <= vmin: vmax = vmin + 1.0
    vol = (vol - vmin) / (vmax - vmin)
    t = torch.from_numpy(vol[None, None, ...]).to(device=device, dtype=torch.float32)

    model.eval()
    with torch.no_grad():
        out = model(t, mode="eval")  # ×”-forward ×©×œ ×”××•×“×œ ×”××œ×

    has_nodule = bool((out.get("has_nodule_detected", torch.tensor(0)) > 0).item())
    if not has_nodule:
        return np.zeros((0, 5), dtype=np.float32)

    cz, cy, cx, rz, ry, rx = out["best_pred"][0].detach().cpu().numpy()
    z = y = x = 128.0
    cz_v, cy_v, cx_v = cz * z, cy * y, cx * x
    diam_v = 2.0 * max(rz * z, ry * y, rx * x)
    return np.array([[1.0, cz_v, cy_v, cx_v, diam_v]], dtype=np.float32)
device = torch.device("cuda" if torch.cuda.is_available() else "cpu")

def load_remote_full_model(weights_url_or_id: str):
    import torch, tempfile

    w_bytes = _download_binary(weights_url_or_id)

    with tempfile.NamedTemporaryFile(delete=False, suffix=".pth") as wf:
        wf.write(w_bytes)
        w_path = wf.name
    device = torch.device("cuda" if torch.cuda.is_available() else "cpu")

    # ğŸ’¥ ×›××Ÿ ×”×©×™× ×•×™ ×”×§×¨×™×˜×™: weights_only=False
    model = torch.load(
        w_path,
        map_location=device,
        weights_only=False  # â† ×—×•×‘×” ×›×©××˜×¢×™× ×™× FULL MODEL
    )

    if not isinstance(model, torch.nn.Module):
        raise RuntimeError("×”×§×•×‘×¥ ××™× ×• FULL MODEL (torch.nn.Module).")
    model.to(device).eval()
    return model, device

def load_remote_full_model1(weights_url_or_id: str):
    import torch, tempfile

    w_bytes = _download_binary(weights_url_or_id)

    with tempfile.NamedTemporaryFile(delete=False, suffix=".pth") as wf:
        wf.write(w_bytes)
        w_path = wf.name

    obj = torch.load(w_path, map_location="cpu")

    if not isinstance(obj, torch.nn.Module):
        raise RuntimeError("×”×§×•×‘×¥ ××™× ×• FULL MODEL.")

    model = obj
    device = torch.device("cuda" if torch.cuda.is_available() else "cpu")
    model.to(device).eval()

    return model, device


def try_model_infer(volume_np: np.ndarray) -> np.ndarray | None:
    try:
        #model = load_remote_full_model(FULL_MODEL_ID)
        model, device = load_remote_full_model(FULL_MODEL_ID)

        #model = load_full_model_from_drive(FULL_MODEL_ID)
        #model = load_full_model_from_url(FULL_MODEL_URL)  # ×˜×¢×™× ×” ××§×•×‘×¥ ××•×“×œ ××œ×
        with torch.no_grad():
            return infer_nodules(volume_np, model, device)
    except Exception as e:
        st.warning(f"Model inference skipped: {e}")
        return None


# ... ×›×œ ×”×¢×–×¨×•×ª ×©×œ ×”××•×“×œ, infer_nodules, try_model_infer ×•×›×•' ...

# ============================================================
# ğŸ”¹ ×¤×•× ×§×¦×™×™×ª ××™××•×Ÿ backend â€“ ×¨×¦×” ×‘×¨×§×¢ ×›×©×œ×•×—×¦×™× Start Training
# ============================================================
from torch.utils.data import DataLoader  # â† ×œ×•×•×“× ×©×–×” ×§×™×™× ××™×¤×©×”×• ×œ××¢×œ×”





# ×ª×§×•×¢ ×›××Ÿ
def try_model_infer_old(volume_np: np.ndarray) -> np.ndarray | None:
    """
    ××¨×™×¥ ××™× ×¤×¨× ×¡ ×¢× ×”××•×“×œ ×”××§×•××™ + ××©×§×•×œ×•×ª ××¨×—×•×§ ×‘×–×¨×™××” ×”×—×¡×™× ×”.
    """
    try:
        model, device = init_model_with_robust_remote_weights(WEIGHTS_URL)
        with torch.no_grad():
            return infer_nodules(volume_np, model, device)
    except Exception as e:
        st.warning(f"Model inference skipped: {e}")
        return None



# ===================== ××¡×›×™× =====================
def render_home():

    st.markdown("<div class='center'>", unsafe_allow_html=True)
    st.markdown("# Lung nodule detection and classification system.")
    st.markdown("## By: Sharon Hanoked")
    st.markdown("### Supervised By Dr. Maya Herman")
    st.markdown("</div>", unsafe_allow_html=True)
    st.markdown("<div class='hr'></div>", unsafe_allow_html=True)

    c1, c2, c3 = st.columns([1,1,1])
    with c1:
        if st.button("ğŸ“˜ USER GUIDE", use_container_width=True):
            st.session_state.page = "guide"
            st.rerun()
    with c2:
        if st.button("ğŸ› ï¸ ADMIN", use_container_width=True):
            st.session_state.page = "admin"
            st.rerun()
    with c3:
        if st.button("ğŸ‘¤ USER", use_container_width=True):
            st.session_state.page = "user"
            st.rerun()


def render_admin():
    st.markdown("## ADMIN")
    st.caption("")

    c1, c2 = st.columns([1, 1])
    with c1:
        if st.button("ğŸ“ˆ System maintenance", use_container_width=True):
            st.session_state.page = "train"
            st.rerun()
    with c2:
        if st.button("ğŸ§ª Analiysis CT image", use_container_width=True):
            st.session_state.page = "test"
            st.rerun()

    st.markdown("<div class='hr'></div>", unsafe_allow_html=True)

    # ×›×¤×ª×•×¨ Back ×‘×œ×™ ×¨×§×¢
    st.markdown('<div class="back-btn">', unsafe_allow_html=True)
    if st.button("â¬…ï¸ Back to Home", type="secondary"):
        st.session_state.page = "home"
        st.rerun()
    st.markdown('</div>', unsafe_allow_html=True)

def render_user():
    st.markdown("## ")

    render_test()

def render_guide():
    st.markdown("## User Guide : Lung nodule detection and classification LUNA16 Challenge")
    st.markdown("*(Base of Luna 16 Grand Challenge)*")
    st.markdown(
        """
     A user-friendly interface for viewing 3D lung CT volumes (NPY, 128Ã—128Ã—128).
     The system automatically analyzes the scan to detect and mark possible lung nodules, indicates whether a nodule is present or not, and shows its exact location.
     Two main image planes â€” **Axial** and **Coronal** â€” are displayed for clear visualization.
     Results can also be compared with Ground Truth annotations to evaluate accuracy.
            """
        )


    st.markdown("### Supported files")
    st.write("- **Volume (required):** NPY, shape [Z, Y, X] = 128Ã—128Ã—128")
    st.write("- **Ground Truth (optional):** NPY, NÃ—5 â€” [class, z, y, x, diameter]")
    st.markdown("### Image analysis colors")
    st.write("- **Green** = Ground Truth")
    st.write("- **Red** = Prediction (Model)")
    st.markdown("### User options")
    st.write(
        "- **Quick check:** Upload the volume; the app states if a nodule exists. "
        "If yes, it draws a bounding box and allows save/download.\n"
        "- **Compare with GT:** Upload volume + GT; the app reports presence in GT and Model, "
        "shows TP/FP/FN/TN, and overlays boxes (Green=GT, Red=Model)."
    )
    st.markdown("### Admin")
    st.write("Train/run the model in the system. Adjustable parameters: Learning rate, Epochs.")
    st.markdown("<div class='hr'></div>", unsafe_allow_html=True)
    if st.button("â¬…ï¸ Back to Home", type="secondary"):
        st.session_state.page = "home"
        st.rerun()

def render_train_placeholder():
    st.markdown("## System maintenance")
    st.markdown("Use this panel to configure and start model training.")
    st.markdown("---")

    # ×××¨×›×–×™× ××ª ×›×œ ×”××œ×× ×˜×™×
    col_spacer1, col_main, col_spacer2 = st.columns([1, 2, 1])
    with col_main:
        st.markdown("### ğŸ§  Training Parameters")

        # ×˜×•×¤×¡ ×”×’×“×¨×•×ª
        learning_rate = st.number_input(
            "Learning rate",
            min_value=1e-6,
            max_value=1.0,
            value=0.001,
            format="%.6f"
        )
        epochs = st.number_input(
            "Epochs",
            min_value=1,
            max_value=1000,
            value=2,
            step=1
        )

        st.markdown("---")

        # ×›×¤×ª×•×¨ ××™××•×Ÿ ×‘××¨×›×–
        train_button_center = st.columns([1, 1, 1])[1]
        with train_button_center:
            if st.button("ğŸš€ Start Training", use_container_width=True):
                st.info("â³ Training is runningâ€¦ please wait. This may take time.")

                # ğŸŸ£ ×”×¨×¦×ª ×”××™××•×Ÿ ×‘×¤×•×¢×œ
                history = run_training_only_train(
                    num_epochs=2,
                    learning_rate=float(learning_rate),

                )

                # ×©××™×¨×ª ×”×’×“×¨×•×ª + ×”×™×¡×˜×•×¨×™×” ×œ-session_state
                st.session_state["train_history"] = history
                st.session_state["train_config"] = {
                    "learning_rate": float(learning_rate),
                    "epochs": 2,
                }

                st.success("âœ” Training finished!")
                st.session_state.page = "train_results"
                st.rerun()

    st.markdown("---")

    # ×›×¤×ª×•×¨ ×—×–×¨×” ×‘×©×•×¨×” ×”×ª×—×ª×•× ×”, ×‘×¦×“ ×©×××œ
    back_col1, _, _ = st.columns([1, 3, 1])
    with back_col1:
        if st.button("â¬…ï¸ Back to Admin", type="secondary"):
            st.session_state.page = "admin"
            st.rerun()



def render_train_results2():
    st.markdown("## ğŸ“Š Training results")

    history = st.session_state.get("train_history", None)
    config = st.session_state.get("train_config", {})

    if history is None or len(history.get("epoch", [])) == 0:
        st.info("×œ× × ××¦××• ×ª×•×¦××•×ª ××™××•×Ÿ ×œ×”×¦×’×”. ×”×¨×™×¦×™ Training ×§×•×“×.")
        if st.button("â¬…ï¸ Back to Training", type="secondary"):
            st.session_state.page = "train"
            st.rerun()
        return

    epochs = history.get(
        "epoch",
        list(range(1, len(history["train_cls_loss"]) + 1))
    )

    # ×›×•×ª×¨×ª ×¢× ×”×¤×¨××˜×¨×™× ×©×©×™××©×• ×œ××™××•×Ÿ
    lr = config.get("learning_rate", None)
    ep = config.get("epochs", None)
    if lr is not None and ep is not None:
        st.write(f"**Learning rate:** `{lr:.6f}` &nbsp;&nbsp; | &nbsp;&nbsp; **Epochs:** `{ep}`")

    st.markdown("<div class='hr'></div>", unsafe_allow_html=True)

    # ×’×•×“×œ ××—×™×“ ×œ×›×œ ×”×’×¨×¤×™×
    FIG_SIZE = (6, 4)

    # =========================
    # 1) Classification Loss + BBox Loss â€“ ×‘×©×•×¨×” ××—×ª
    # =========================
    col1, col2 = st.columns(2)

    with col1:
        fig1, ax1 = plt.subplots(figsize=FIG_SIZE)
        ax1.plot(epochs, history["train_cls_loss"], label="Train classification loss")
        ax1.plot(epochs, history["val_cls_loss"],   label="Val classification loss")
        ax1.set_title("Classification loss per epoch")
        ax1.set_xlabel("Epoch")
        ax1.set_ylabel("Loss")
        ax1.grid(True)
        ax1.legend()
        fig1.tight_layout()
        st.pyplot(fig1, use_container_width=True)

    with col2:
        fig2, ax2 = plt.subplots(figsize=FIG_SIZE)
        ax2.plot(epochs, history["train_bbox_loss"], label="Train bbox loss")
        ax2.plot(epochs, history["val_bbox_loss"],   label="Val bbox loss")
        ax2.set_title("BBox loss per epoch")
        ax2.set_xlabel("Epoch")
        ax2.set_ylabel("Loss")
        ax2.grid(True)
        ax2.legend()
        fig2.tight_layout()
        st.pyplot(fig2, use_container_width=True)

    st.markdown("<div class='hr'></div>", unsafe_allow_html=True)

    # =========================
    # 2) Accuracy
    # =========================
    fig3, ax3 = plt.subplots(figsize=FIG_SIZE)
    ax3.plot(epochs, history["train_acc"], label="Train accuracy")
    ax3.plot(epochs, history["val_acc"],   label="Val accuracy")
    ax3.set_title("Accuracy per epoch")
    ax3.set_xlabel("Epoch")
    ax3.set_ylabel("Accuracy")
    ax3.grid(True)
    ax3.legend()
    fig3.tight_layout()
    st.pyplot(fig3, use_container_width=True)

    st.markdown("<div class='hr'></div>", unsafe_allow_html=True)

    # =========================
    # 3) IoU + Dice â€“ ×‘×©×•×¨×” ××—×ª
    # =========================
    col3, col4 = st.columns(2)

    with col3:
        fig4, ax4 = plt.subplots(figsize=FIG_SIZE)
        ax4.plot(epochs, history["train_iou"], label="Train IoU")
        ax4.plot(epochs, history["val_iou"],   label="Val IoU")
        ax4.set_title("IoU per epoch")
        ax4.set_xlabel("Epoch")
        ax4.set_ylabel("IoU")
        ax4.grid(True)
        ax4.legend()
        fig4.tight_layout()
        st.pyplot(fig4, use_container_width=True)

    with col4:
        fig5, ax5 = plt.subplots(figsize=FIG_SIZE)
        ax5.plot(epochs, history["train_dice"], label="Train Dice")
        ax5.plot(epochs, history["val_dice"],   label="Val Dice")
        ax5.set_title("Dice per epoch")
        ax5.set_xlabel("Epoch")
        ax5.set_ylabel("Dice")
        ax5.grid(True)
        ax5.legend()
        fig5.tight_layout()
        st.pyplot(fig5, use_container_width=True)

    st.markdown("<div class='hr'></div>", unsafe_allow_html=True)

    # ×›×¤×ª×•×¨×™ × ×™×•×•×˜
    c1, c2, c3 = st.columns([1, 1, 1])
    with c1:
        if st.button("â¬…ï¸ Back to Training", type="secondary"):
            st.session_state.page = "train"
            st.rerun()
    with c2:
        if st.button("â¬…ï¸ Back to Admin", type="secondary", key="back_admin_from_results"):
            st.session_state.page = "admin"
            st.rerun()

def render_train_results():
    st.markdown("## ğŸ“Š Training results")

    history = st.session_state.get("train_history", None)
    config = st.session_state.get("train_config", {})

    if history is None or len(history.get("epoch", [])) == 0:
        st.info("×œ× × ××¦××• ×ª×•×¦××•×ª ××™××•×Ÿ ×œ×”×¦×’×”. ×”×¨×™×¦×™ Training ×§×•×“×.")
        if st.button("â¬…ï¸ Back to Training", type="secondary"):
            st.session_state.page = "train"
            st.rerun()
        return

    # ×¦×™×¨ X (××¤×•×§×™×)
    epochs = history.get(
        "epoch",
        list(range(1, len(history["train_cls_loss"]) + 1))
    )

    # ×›×•×ª×¨×ª ×¢× ×”×¤×¨××˜×¨×™× ×©×©×™××©×• ×œ××™××•×Ÿ
    lr = config.get("learning_rate", None)
    ep = config.get("epochs", None)
    if lr is not None and ep is not None:
        st.write(f"**Learning rate:** `{lr:.6f}` &nbsp;&nbsp; | &nbsp;&nbsp; **Epochs:** `{ep}`")

    st.markdown("<div class='hr'></div>", unsafe_allow_html=True)

    # ×’×•×“×œ ×‘×¡×™×¡×™ ×œ×›×œ ×”×’×¨×¤×™×
    FIG_SIZE = (6, 4)

    # =========================
    # 1) Classification Loss + BBox Loss â€“ ×‘×©×•×¨×” ××—×ª
    # =========================
    col1, col2 = st.columns(2)

    # ---- Classification loss ----
    with col1:
        fig1, ax1 = plt.subplots(figsize=FIG_SIZE)
        ax1.plot(epochs, history["train_cls_loss"], label="Train classification loss")
        ax1.plot(epochs, history["val_cls_loss"],   label="Val classification loss")
        ax1.set_title("Classification loss per epoch")
        ax1.set_xlabel("Epoch")
        ax1.set_ylabel("Loss")
        ax1.grid(True)
        ax1.legend()
        fig1.tight_layout()
        st.pyplot(fig1, use_container_width=True)

    # ---- BBox loss ----
    with col2:
        fig2, ax2 = plt.subplots(figsize=FIG_SIZE)
        ax2.plot(epochs, history["train_bbox_loss"], label="Train bbox loss")
        ax2.plot(epochs, history["val_bbox_loss"],   label="Val bbox loss")
        ax2.set_title("BBox loss per epoch")
        ax2.set_xlabel("Epoch")
        ax2.set_ylabel("Loss")
        ax2.grid(True)
        ax2.legend()
        fig2.tight_layout()
        st.pyplot(fig2, use_container_width=True)

    st.markdown("<div class='hr'></div>", unsafe_allow_html=True)

    # =========================
    # 2) Accuracy + Dice â€“ ×‘×©×•×¨×” ××—×ª
    # =========================
    col3, col4 = st.columns(2)

    # ---- Accuracy ----
    with col3:
        fig3, ax3 = plt.subplots(figsize=FIG_SIZE)
        ax3.plot(epochs, history["train_acc"], label="Train accuracy")
        ax3.plot(epochs, history["val_acc"],   label="Val accuracy")
        ax3.set_title("Accuracy per epoch")
        ax3.set_xlabel("Epoch")
        ax3.set_ylabel("Accuracy")
        ax3.grid(True)
        ax3.legend()
        fig3.tight_layout()
        st.pyplot(fig3, use_container_width=True)

    # ---- Dice ----
    with col4:
        fig5, ax5 = plt.subplots(figsize=FIG_SIZE)
        ax5.plot(epochs, history["train_dice"], label="Train Dice")
        ax5.plot(epochs, history["val_dice"],   label="Val Dice")
        ax5.set_title("Dice per epoch")
        ax5.set_xlabel("Epoch")
        ax5.set_ylabel("Dice")
        ax5.grid(True)
        ax5.legend()
        fig5.tight_layout()
        st.pyplot(fig5, use_container_width=True)

    st.markdown("<div class='hr'></div>", unsafe_allow_html=True)

    # =========================
    # ×›×¤×ª×•×¨×™ × ×™×•×•×˜
    # =========================
    c1, c2, c3 = st.columns([1, 1, 1])
    with c1:
        if st.button("â¬…ï¸ Back to Training", type="secondary"):
            st.session_state.page = "train"
            st.rerun()
    with c2:
        if st.button("â¬…ï¸ Back to Admin", type="secondary", key="back_admin_from_results"):
            st.session_state.page = "admin"
            st.rerun()


def render_train_placeholder1():
    st.markdown("## System maintenance")
    st.markdown("Use this panel to configure and start model training.")

    st.markdown("---")

    # ×××¨×›×–×™× ××ª ×›×œ ×”××œ×× ×˜×™×
    col_spacer1, col_main, col_spacer2 = st.columns([1, 2, 1])
    with col_main:
        st.markdown("### ğŸ§  Training Parameters")

        # ×˜×•×¤×¡ ×”×’×“×¨×•×ª
        learning_rate = st.number_input("Learning rate", min_value=1e-6, max_value=1.0, value=0.001, format="%.6f")
        epochs = st.number_input("Epochs", min_value=1, max_value=1000, value=50, step=1)
        #batch_size = st.number_input("Batch size", min_value=1, max_value=128, value=8, step=1)
        #optimizer = st.selectbox("Optimizer", ["Adam", "AdamW", "SGD", "RMSprop"], index=1)
        #loss_fn = st.selectbox("Loss function", ["BCEWithLogitsLoss", "FocalLoss", "SmoothL1Loss"], index=0)

        st.markdown("---")

        # ×›×¤×ª×•×¨ ××™××•×Ÿ ×‘××¨×›×–
        train_button_center = st.columns([1, 1, 1])[1]
        with train_button_center:
            if st.button("ğŸš€ Start Training", use_container_width=True):
                st.success("Training started... (This is a placeholder demo.)")

    st.markdown("---")

    # ×›×¤×ª×•×¨ ×—×–×¨×” ×‘×©×•×¨×” ×”×ª×—×ª×•× ×”, ×‘×¦×“ ×©×××œ
    back_col1, _, _ = st.columns([1, 3, 1])
    with back_col1:
        if st.button("â¬…ï¸ Back to Admin", type="secondary"):
            st.session_state.page = "admin"
            st.rerun()

# ×‘×ª×—×™×œ×ª ×”×§×•×‘×¥ ×¤×¢× ××—×ª (×× ××™×Ÿ):
if "test_step" not in st.session_state:
    st.session_state["test_step"] = "form"


def render_test():
    step = st.session_state.get("test_step", "form")

    # ===== ×©×œ×‘ 1: ×˜×•×¤×¡ ×”×¢×œ××” ×‘×××¦×¢, ×œ×œ× Options =====
    if step == "form":
        st.markdown("## Image analysis â€“ Upload")

        # --- NPY Volume row (label + uploader ×‘××•×ª×” ×©×•×¨×”) ---
        c1, c2 = st.columns([1, 2])
        with c1:
            st.markdown("**Enter 3D CT Image size 128*128*128**")
        with c2:
            vol_file = st.file_uploader(
                label=" ", type=["npy"], key="vol_up", label_visibility="collapsed"
            )

        # --- labels.npy row ---
        c3, c4 = st.columns([1, 2])
        with c3:
            st.markdown("**Enter avaiiable true analyzed results â€“ (Optional)**")
        with c4:
            lbl_file = st.file_uploader(
                label=" ", type=["npy"], key="lbl_up", label_visibility="collapsed"
            )

        # --- preds.npy row (×× ××ª ×¨×•×¦×” ×œ×”×©××™×¨; ××¤×©×¨ ×œ××—×•×§ ××ª ×”×‘×œ×•×§ ×”×–×”) ---
        #c5, c6 = st.columns([1, 2])
        #with c5:
        #    st.markdown("**preds.npy (Model, NÃ—5) â€“ (Optional)**")
        #with c6:
        #    pd_file = st.file_uploader(
        #        label=" ", type=["npy"], key="pd_up", label_visibility="collapsed"
        #    )

        # --- ×›×¤×ª×•×¨×™×: BACK ××©×××œ ×œ××˜×”, ANALYZE ×××•×¨×›×– ---
        st.markdown("---")
        left, center, right = st.columns([1, 1, 1])

        with left:
            if st.button("â¬…ï¸ Back to Home", type="secondary", key="back_home_upload"):
                st.session_state.page = "home"
                st.session_state.pop("test_data", None)
                st.session_state["test_step"] = "form"
                st.rerun()

        with center:
            can_run = vol_file is not None
            if st.button("â–¶ï¸ Analyze", use_container_width=True, disabled=not can_run, key="analyze_btn"):
                import numpy as np
                try:
                    vol = np.squeeze(np.load(vol_file))
                    labels_np = np.load(lbl_file) if lbl_file is not None else None
                    preds_np=None
                except Exception as e:
                    st.error(f"File read error: {e}")
                    return
                if vol.ndim != 3:
                    st.error(f"Expected 3D volume. Got shape={vol.shape}")
                    return

                # ×‘×¨×™×¨×•×ª ××—×“×œ ×›×™ ××™×Ÿ Options ×‘××¡×š:
                iou_thr = 0.10
                full_width = True
                show_headers = False

                st.session_state["test_data"] = dict(
                    vol=vol, labels_np=labels_np, preds_np=None,
                    iou_thr=iou_thr, full_width=full_width, show_headers=show_headers
                )
                st.session_state["test_step"] = "results"
                st.rerun()

        # ×ª× ×¨×™×§ ×›×“×™ ×œ×©××•×¨ ×¢×œ ×”×¤×¨×™×¡×”
        with right:
            st.write("")

    # ===== ×©×œ×‘ 2: ×ª×•×¦××•×ª (×›××• ×©×”×™×”, ×¨×§ ×¢× ×‘×¨×™×¨×•×ª ××—×“×œ) =====
    else:
        st.markdown("## Image analysis â€“ Results")

        td = st.session_state.get("test_data")
        if td is None:
            st.session_state["test_step"] = "form"
            st.rerun()
            return

        vol        = td["vol"]
        labels_np  = td["labels_np"]
        #preds_np   = td["preds_np"]A

        iou_thr    = td["iou_thr"]
        full_width = td["full_width"]
        show_headers = td["show_headers"]

        # === ×—×“×©: ×× ×œ× ×”×•×¢×œ×” preds.npy â€“ × × ×¡×” ×œ×”×¨×™×¥ ××™× ×¤×¨× ×¡ ××•×˜×•××˜×™ ××”××•×“×œ ×”××¨×•×—×§ ===
        preds_np = td.get("preds_np", None)
        # ×× ×œ× ×”×•×¢×œ×” preds.npy â€“ ××¨×™×¦×•×ª ××™× ×¤×¨× ×¡ ××§×•××™ ×œ×”×“×¤×¡×”/×‘×“×™×§×” (×œ×œ× ×”×•×¨×“×”)
        if preds_np is None:
            preds_np = try_model_infer(vol)
            st.session_state["test_data"]["preds_np"] = preds_np

        import numpy as np
        #st.markdown("#### ğŸ” Console mirror (×”×¢×ª×§ ×œ×œ×•×’ + ×ª×¦×•×’×” ×›××Ÿ)")

        if preds_np is None:
            st.text("preds_np = None (××™×Ÿ ×¤×œ×˜ ××”××•×“×œ)")
        #else:
        #    st.text(f"type: {type(preds_np)}")
        #    if isinstance(preds_np, np.ndarray):
        #        st.text(f"shape: {preds_np.shape}, dtype: {preds_np.dtype}")
        #        st.code(np.array2string(
        #            preds_np, precision=3, threshold=10**9, max_line_width=200
        #        ))
        #    else:
        #        st.text(f"value: {preds_np}")


        ###

        # × ×©××•×¨ ×‘×–×™×›×¨×•×Ÿ ×›×“×™ ×©×œ× × ×¨×™×¥ ×©×•×‘ ×‘-refresh
        st.session_state["test_data"]["preds_np"] = preds_np

        Z, Y, X = vol.shape
        gt_boxes, order_gt = parse_boxes(labels_np, Z, Y, X)
        pd_boxes, order_pd = parse_boxes(preds_np,  Z, Y, X)

        # --- ×”×¦×’×ª Yes/No ×‘×¨×•×¨ ×œ×–×™×”×•×™ × ×•×“×•×œ×” ×¢"×™ ×”××•×“×œ ---
        detected = len(pd_boxes) > 0
        st.markdown(f"### Nodule detected: {'âœ… Yes' if detected else 'âŒ No'}")

        #st.caption(
        #    f"Volume: Z={Z}, Y={Y}, X={X} | dtype={vol.dtype} | "
        #    f"GT: {len(gt_boxes)} (order {order_gt.upper()}) | "
        #    f"Preds: {len(pd_boxes)} (order {order_pd.upper()})"
        #)

        has_gt, has_pd = len(gt_boxes) > 0, len(pd_boxes) > 0
        if not has_gt and not has_pd:
            st.success("TN â€“ No nodule in GT and no detection in model.")
            st.markdown("<div class='hr'></div>", unsafe_allow_html=True)
        elif not has_gt and has_pd:
            st.warning("FP â€“ No nodule in GT but model detected. (Per your request images not shown)")
            st.markdown("<div class='hr'></div>", unsafe_allow_html=True)
        elif has_gt and not has_pd:
            st.error("FN â€“ Nodule in GT but no detection in model.")
        #else:
        #    #matches, un_gt, un_pd = match_greedy(gt_boxes, pd_boxes, iou_thr=iou_thr)
        #    #st.success(f"TP â€“ Matches: TP={len(matches)}, FP={len(un_pd)}, FN={len(un_gt)} (IoUâ‰¥{iou_thr}).")
        #    st.success("**TP** â€“ A nodule was detected both in the ground-truth and in the model.")

        else:
            # ×™×© ×’× GT ×•×’× Preds â†’ × ×‘×“×•×§ ×”×ª×××•×ª (TP) ×œ×¤×™ IoU
            matches, un_gt, un_pd = match_greedy(gt_boxes, pd_boxes, iou_thr=iou_thr)

            if len(matches) > 0:
                # ×—×™×©×•×‘ IoU ×•-Dice ×œ×›×œ ×”×”×ª×××•×ª
                ious = [m[2] for m in matches]  # iou ××›×œ match
                mean_iou = sum(ious) / len(ious)

                # Dice = 2 * IoU / (1 + IoU)
                dices = [2 * i / (1 + i) for i in ious]
                mean_dice = sum(dices) / len(dices)
                st.success(
                    f"**TP** â€“ A nodule was detected both in the ground-truth and in the model. "
                    f"| **IoU:** {mean_iou:.3f} | **Dice:** {mean_dice:.3f}"
                )



                st.success("**TP** â€“ A nodule was detected both in the ground-truth and in the model.")
                st.write(f"**IoU:** {mean_iou:.3f}")
                st.write(f"**Dice:** {mean_dice:.3f}")

            else:
                # ×™×© ×’× GT ×•×’× Preds ××‘×œ ×‘×œ×™ ×”×ª×××” ××¢×œ ×”×¡×£ â†’ ×‘×¤×•×¢×œ FP+FN
                st.warning(
                    f"No matched boxes at IoU â‰¥ {iou_thr}. (GT={len(gt_boxes)}, Preds={len(pd_boxes)})"
                )


        # --- ×¡×™×›×•× 4 ×”××¦×‘×™× (TP/FP/FN/TN) ×‘×¦×•×¨×” ××—×™×“×” ---
        has_gt = len(gt_boxes) > 0
        has_pd = len(pd_boxes) > 0
        if not has_gt and not has_pd:
            st.success("**TN** â€“ No nodule in GT and no detection in model.")
            st.markdown("<div class='hr'></div>", unsafe_allow_html=True)
        elif not has_gt and has_pd:
            st.warning("**FP** â€“ Model detected a nodule but **GT has none**. (Per your request images not shown)")
            st.markdown("<div class='hr'></div>", unsafe_allow_html=True)
        elif has_gt and not has_pd:
            st.error("**FN** â€“ GT has a nodule but **model found none**.")
        #else:
            # ×™×© ×’× GT ×•×’× Preds â†’ × ×‘×“×•×§ ×”×ª×××•×ª (TP) ×œ×¤×™ IoU
            #matches, un_gt, un_pd = match_greedy(gt_boxes, pd_boxes, iou_thr=iou_thr)
            #if len(matches) > 0:
            #    st.success(f"**TP** â€“ {len(matches)} matches (IoU â‰¥ {iou_thr}).  FP={len(un_pd)}, FN={len(un_gt)}")
            #else:
            # ×™×© ×’× GT ×•×’× Preds ××‘×œ ×‘×œ×™ ×”×ª×××•×ª (×‘×¤×•×¢×œ: FP ×•Ö¾FN ×‘××§×‘×™×œ)
            #st.warning(f"No matched boxes at IoU â‰¥ {iou_thr}. (GT={len(gt_boxes)}, Preds={len(pd_boxes)})")


        # ×‘×—×™×¨×ª ×¤×¨×•×¡×•×ª
        if has_gt:
            z_main = clamp(int(round(gt_boxes[0][0])), 0, Z-1)
            x_main = clamp(int(round(gt_boxes[0][2])), 0, X-1)
        else:
            z_main = clamp(int(round(pd_boxes[0][0])), 0, Z-1) if has_pd else 0
            x_main = clamp(int(round(pd_boxes[0][2])), 0, X-1) if has_pd else 0
          # ×ª×—×™×œ×ª ×‘×œ×•×§ 1
        # ×ª×—×™×œ×ª ×‘×œ×•×§ 1 â€” ×—×“×©
        # ============= Per-nodule views (separate GT & Model, outline-only, correct axes & smaller images) =============
        if has_gt or has_pd:
            #st.markdown("---")
            st.subheader("Per-nodule views (GT vs Model)")

            # ×©×œ×™×˜×” ×‘×’×•×“×œ ×ª××•× ×•×ª
            IMG_WIDTH = 420  # ×”×§×˜× ×ª ×ª××•× ×•×ª; ××¤×©×¨ ×œ×©× ×•×ª ×œ-300/360 ×•×›×•'

            def get_axial(vol, z_idx):
                return slice_to_pil(vol[clamp(int(round(z_idx)), 0, Z-1)])

            def get_coronal(vol, x_idx):
                return slice_to_pil(vol[:, :, clamp(int(round(x_idx)), 0, X-1)])

            def draw_rect_outline1(img, cx, cy, diam, color):
                dr = ImageDraw.Draw(img)
                r = float(diam) / 2.0
                dr.rectangle([(cx - r, cy - r), (cx + r, cy + r)], outline=color, width=3)  # ×§×•× ×˜×•×¨ ×‘×œ×‘×“
            def draw_rect_outline(img, cx, cy, diam, color):
                dr = ImageDraw.Draw(img)
                r = float(diam) / 2.0
                x0, y0 = cx - r, cy - r
                x1, y1 = cx + r, cy + r
                # ×§×•× ×˜×•×¨ ×‘×œ×‘×“ (×œ×œ× fill)
                dr.rectangle([(x0, y0), (x1, y1)], outline=color, width=1, fill=None)
            GREEN = (0, 255, 0)
            RED   = (255, 0, 0)

            # ×”×ª×××•×ª ×œ×¤×™ IoU
            matches, un_gt, un_pd = match_greedy(gt_boxes, pd_boxes, iou_thr=iou_thr)
            match_map = {gi: (pi, iou) for (gi, pi, iou) in matches}

            if has_gt:
                # ×¢×‘×•×¨ ×›×œ GT â€“ ××¦×™×’×™× ××ª ×”-GT ×¢×œ ×¤×¨×•×¡×•×ª ×”-GT ×©×œ×•,
                # ×•×× ×™×© ×”×ª×××” â€“ ××¦×™×’×™× ××ª ×”××•×“×œ ×¢×œ ×”×¤×¨×•×¡×•×ª ×©×œ ×”××•×“×œ (Z/X ××©×œ×•!)
                for i, (zg, yg, xg, dg, clsg) in enumerate(gt_boxes, start=1):
                    zgi = clamp(int(round(zg)), 0, Z-1)
                    xgi = clamp(int(round(xg)), 0, X-1)

                    #st.markdown(f"### ğŸ« Nodule {i} (GT) â€” diam={dg:.1f}")

                    # GT Axial (Z=zgi) â€” ××¦×™×™×¨×™× ×‘×§×•××•×¨×“×™× ×˜×•×ª (xg, yg)

                    #img_gt_ax = get_axial(vol, zgi).copy()
                    #draw_rect_outline(img_gt_ax, xg, yg, dg, GREEN)
                    #st.image(
                    #    img_gt_ax, width=IMG_WIDTH,
                    #    caption=f"ğŸŸ© GT â€” Axial (Z={zgi}) â€¢ center (x={int(round(xg))}, y={int(round(yg))}, z={int(round(zg))})"
                    #)

                    # Model Axial ×¢×œ ×¤×¨×•×¡×ª Z ×©×œ ×”××•×“×œ (×× ×§×™×™××ª ×”×ª×××”)

                    # Model Axial â€“ ×ª××™×“ ××•×¦×’, ×‘×œ×™ IoU ×•×‘×œ×™ ×ª× ××™
                    #if len(pd_boxes) > 0:
                    #    zp, yp, xp, dp, _ = pd_boxes[0]
                    #    zpi = clamp(int(round(zp)), 0, Z-1)

                    #   img_md_ax = get_axial(vol, zpi).copy()
                    #    draw_rect_outline(img_md_ax, xp, yp, dp, RED)  # âœ… ××¦×™×™×¨ in-place, ×‘×œ×™ ×”×©××”
                    #    #st.image(img_md_ax, width=IMG_WIDTH, caption=...)
                    #    st.image(
                    #        img_md_ax,
                    #        width=IMG_WIDTH,
                    #        caption=f"ğŸŸ¥ Model â€” Axial (Z={int(round(zp))}, Y={int(round(yp))}, X={int(round(xp))})"
                    #    )
                    #else:
                    #    st.info("No model predictions found.")
                    # --- Axial row: GT | Model ---
                    col_ax_gt, col_ax_md = st.columns(2)

                    # GT Axial (Z=zgi)
                    with col_ax_gt:
                        img_gt_ax = get_axial(vol, zgi).copy()
                        draw_rect_outline(img_gt_ax, xg, yg, dg, GREEN)
                        st.image(
                            img_gt_ax, width=IMG_WIDTH,
                            caption=f"ğŸŸ© GT â€” Axial (Z={zgi}) â€¢ center (x={int(round(xg))}, y={int(round(yg))}, z={int(round(zg))})"
                        )

                    # Model Axial
                    with col_ax_md:
                        if len(pd_boxes) > 0:
                            zp, yp, xp, dp, _ = pd_boxes[0]
                            zpi = clamp(int(round(zp)), 0, Z-1)
                            img_md_ax = get_axial(vol, zpi).copy()
                            draw_rect_outline(img_md_ax, xp, yp, dp, RED)
                            st.image(
                                img_md_ax,
                                width=IMG_WIDTH,
                                caption=f"ğŸŸ¥ Model â€” Axial (Z={int(round(zp))}, Y={int(round(yp))}, X={int(round(xp))})"
                            )
                        else:
                            st.info("No model predictions found.")


                    # GT Coronal (X=xgi) â€” ×‘×§×•××•×¨×“×™× ×˜×•×ª (y,z) ×‘×’×œ×œ ×”×—×ª×š ×‘×¦×™×¨ X
                    #img_gt_co = get_coronal(vol, xgi).copy()
                    #draw_rect_outline(img_gt_co, yg, zg, dg, GREEN)
                    #st.image(
                    #    img_gt_co, width=IMG_WIDTH,
                    #    caption=f"ğŸŸ© GT â€” Coronal (X={xgi}) â€¢ center (x={int(round(xg))}, y={int(round(yg))}, z={int(round(zg))})"
                    #)


                    # Model Coronal â€“ ×ª××™×“ ××•×¦×’, ×‘×œ×™ IoU ×•×‘×œ×™ ×ª× ××™× ××•×§×“××™×
                    #if len(pd_boxes) > 0:
                    #    zp, yp, xp, dp, _ = pd_boxes[0]
                    #    xpi = clamp(int(round(xp)), 0, X-1)

                    #    img_md_co = get_coronal(vol, xpi).copy()
                    #    draw_rect_outline(img_md_co, yp, zp, dp, RED)  # âœ…

                    #    st.image(
                    #        img_md_co,
                    #        width=IMG_WIDTH,
                    #        caption=f"ğŸŸ¥ Model â€” Coronal (Z={int(round(zp))}, Y={int(round(yp))}, X={int(round(xp))})"
                    #    )
                    #else:
                    #    st.info("No model predictions found.")
                    # --- Coronal row: GT | Model ---
                    col_co_gt, col_co_md = st.columns(2)

                    # GT Coronal (X=xgi)
                    with col_co_gt:
                        img_gt_co = get_coronal(vol, xgi).copy()
                        draw_rect_outline(img_gt_co, yg, zg, dg, GREEN)
                        st.image(
                            img_gt_co, width=IMG_WIDTH,
                            caption=f"ğŸŸ© GT â€” Coronal (X={xgi}) â€¢ center (x={int(round(xg))}, y={int(round(yg))}, z={int(round(zg))})"
                        )

                    # Model Coronal
                    with col_co_md:
                        if len(pd_boxes) > 0:
                            zp, yp, xp, dp, _ = pd_boxes[0]
                            xpi = clamp(int(round(xp)), 0, X-1)
                            img_md_co = get_coronal(vol, xpi).copy()
                            draw_rect_outline(img_md_co, yp, zp, dp, RED)
                            st.image(
                                img_md_co,
                                width=IMG_WIDTH,
                                caption=f"ğŸŸ¥ Model â€” Coronal (Z={int(round(zp))}, Y={int(round(yp))}, X={int(round(xp))})"
                            )
                        else:
                            st.info("No model predictions found.")

                    st.markdown("---")

            # ×× ××™×Ÿ GT ×‘×›×œ×œ â€” ××¦×™×’×™× ××ª ×›×œ ×”× ×•×“×•×œ×•×ª ×©×—×–×” ×”××•×“×œ (×›×œ ××—×ª ×‘× ×¤×¨×“, 2 ×¤×¨×•×¡×•×ª ×¢×œ ×”×¦×™×¨×™× ×©×œ ×”××•×“×œ)
            if not has_gt and has_pd:
                for i, (z, y, x, d, cls) in enumerate(pd_boxes, start=1):
                    zi = clamp(int(round(z)), 0, Z-1)
                    xi = clamp(int(round(x)), 0, X-1)
                    #st.markdown(f"### ğŸ” Predicted Nodule {i} â€” diam={d:.1f}")

                    img_md_ax = get_axial(vol, zi).copy()
                    draw_rect_outline(img_md_ax, x, y, d, RED)
                    st.image(
                        img_md_ax, width=IMG_WIDTH,
                        caption=f"ğŸŸ¥ Model â€” Axial (Z={zi}) â€¢ center (x={int(round(x))}, y={int(round(y))}, z={int(round(z))})"
                    )

                    img_md_co = get_coronal(vol, xi).copy()
                    draw_rect_outline(img_md_co, y, z, d, RED)
                    st.image(
                        img_md_co, width=IMG_WIDTH,
                        caption=f"ğŸŸ¥ Model â€” Coronal (X={xi}) â€¢ center (x={int(round(x))}, y={int(round(y))}, z={int(round(z))})"
                    )

                    #st.markdown("---")
        # ×¡×•×£ ×‘×œ×•×§ 1 â€” ×—×“×©


        # ×¡×•×£ ×‘×œ×•×§ 1
        #st.markdown("---")
        l, m, r = st.columns([1, 1, 1])
        with l:
            if st.button("â¬…ï¸ Back to Upload", type="secondary", key="back_upload_results"):
                st.session_state["test_step"] = "form"
                st.rerun()
        with m:
            # ××§×•× ×¨×™×§ ×›×“×™ ×œ×”×©××™×¨ ××ª Back Home ×‘×¦×“ ×©×××œ
            st.write("")
        with r:
            # ×¨×™×§
            st.write("")

        # Back Home ×”×›×™ ×œ××˜×”, ×©×××œ
        #bl, bm, br = st.columns([1, 1, 1])
        #with bl:
        #    if st.button("â¬…ï¸ Back to Home", type="secondary", key="back_home_results"):
        #        st.session_state.page = "home"
        #        st.session_state.pop("test_data", None)
        #        st.session_state["test_step"] = "form"
        #        st.rerun()



#######################

# ===================== Router =====================
if st.session_state.page == "home":
    render_home()
elif st.session_state.page == "admin":
    render_admin()
elif st.session_state.page == "user":
    render_user()
elif st.session_state.page == "guide":
    render_guide()
elif st.session_state.page == "train":
    render_train_placeholder()
elif st.session_state.page == "train_results":
    render_train_results()      # â† â† â† ×›××Ÿ ×”×§×¨×™××” ××ª×‘×¦×¢×ª ×‘×¤×•×¢×œ
elif st.session_state.page == "test":
    render_test()
else:
    render_home()